// face.js is where the logic happens
import { getImage } from "./util/img.js";


/**
 * @param {any} obj
 * @param {number} defaultVal */
function getNumber(obj, defaultVal) {
	const num = Number(obj);
	return !isNaN(num) ? num : defaultVal;
}

/** @type {Object<string,HTMLImageElement>} */
const sussy = {
	base: null, // white sussy (no color)
	visor: null, // sussy mask
	colored: null, // colored sussy (generated by applying color to base and then drawing mask on top)
};



export class Sussymoji {

    /** @type {HTMLImageElement} */
	_img = null;

    /**
     * @param { Object<string,string> } cookie 
     * @param { string } containerID
     */
    constructor(cookie, containerID = "container") {     
   
        /** multiplier that gets applied to img width/height */
        this.size = getNumber(cookie.size, 1);
        /** current offset for rendering  */
        this.pos = {
            x: getNumber(cookie.x, 60),
            y: getNumber(cookie.y, 60),
        };

        
        this.container = document.getElementById(containerID);
        const canvas = document.getElementsByTagName("canvas")[0];
        const ctx = canvas.getContext("2d");
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        this.ctx = ctx;
    }


	/** 
	 * @param {HTMLImageElement} img 
	 * @param {boolean?} _render
	*/
	setImage(img, _render = true) {
		this._img = img;
		$("#face").attr("src", img.src);
		if (_render) this.render();
	}

	get img() {
		return this._img;
	}

    render() {
        const ctx = this.ctx;
        const canvas = ctx.canvas;
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    
        // need to draw from center so it scales from center
        const width = this.img.width * this.size;
        const height = this.img.height * this.size;
        const left = (this.pos.x / 100) * canvas.width - width / 2;
        const top = canvas.height - (this.pos.y / 100) * canvas.height - height / 2;
    
        // draw  face
        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = "source-over";
        ctx.drawImage(this.img, left, top, width, height);
    
        // clip to visor
        ctx.globalCompositeOperation = "destination-in";
        ctx.drawImage(sussy.visor, 0, 0);
    
        // re-draw sussy behind
        ctx.globalCompositeOperation = "destination-over";
        ctx.drawImage(sussy.colored, 0, 0);
    
        // draw visor on top (reduced opacity)
        ctx.globalAlpha = 0.33;
        ctx.globalCompositeOperation = "source-over";
        ctx.drawImage(sussy.visor, 0, 0);
    }


    /** loads images, then scales canvas/container to fit */
    async load() {
        // TODO: store previous image in cookie isntead of always loading austo?
        this._img = await getImage("img/austo.png");
        sussy.base = await getImage("img/sussy.png");
        sussy.visor = await getImage("img/visor.png");

        // scaling canvas and container
        this.ctx.canvas.width = sussy.base.width;
        this.ctx.canvas.height = sussy.base.height;

        const w_ratio = 100 * sussy.base.width / sussy.base.height;
        this.container.style.maxWidth = w_ratio + "vh";

        //const h_ratio = 100 * sussy.base.height / sussy.base.width;
        //this.container.style.height = h_ratio + "vw";       
    }
    


    /** @param {string} color */
    async setColor(color) {
        const tempCanvas = document.createElement("canvas");
			tempCanvas.width = this.ctx.canvas.width;
			tempCanvas.height = this.ctx.canvas.height;

			const tempCtx = tempCanvas.getContext("2d");
			tempCtx.fillStyle = color;

			// draw sussy
			tempCtx.drawImage(sussy.base, 0, 0, tempCanvas.width, tempCanvas.height);

			// geting sussy overlay: "source-in" only fills rect where intersecting with sussy
			tempCtx.globalCompositeOperation = "source-in";
			tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

			// now load sussy overlay into an image (can't apply globalCompositeOperation to imageData unfortunately)
			const overlay = await getImage(tempCanvas.toDataURL())
			tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);

			// draw sussy again
			tempCtx.globalCompositeOperation = "source-over";
			tempCtx.drawImage(sussy.base, 0, 0, tempCanvas.width, tempCanvas.height);

			// apply color
			tempCtx.globalCompositeOperation = "multiply";
			tempCtx.drawImage(overlay, 0, 0, tempCanvas.width, tempCanvas.height);

			// draw visor
			//tempCtx.globalCompositeOperation = "source-over";
			//tempCtx.drawImage(sussy.visor, 0, 0, tempCanvas.width, tempCanvas.height);

			sussy.colored = await getImage(tempCanvas.toDataURL());
			this.render();
    }
};