const pos = {
    x: 180,
    y: 220
};


/** @type {Object<string,HTMLImageElement>} */
const sussy = {
    base: null,         // white sussy (no color)
    mask: null,         // sussy mask
    colored: null       // colored sussy (generated by applying color to base and then drawing mask on top)
};



let emoji = String.fromCodePoint(0x1F602);


const container = document.getElementById("canvas");
const canvases = document.getElementsByTagName("canvas");
const canvas = {
    emoji: canvases[0],
    sussy: canvases[1]
};
const ctx = {
    emoji: canvas.emoji.getContext("2d"),
    sussy: canvas.sussy.getContext("2d")
}

ctx.emoji.textAlign = "center";
ctx.emoji.textBaseline = "middle";


function init() {
    // scaling canvas
    sussy.default.width /= 4;
    sussy.default.height /= 4;
    canvas.emoji.width = canvas.sussy.width = sussy.default.width;
    canvas.emoji.height = canvas.sussy.height = sussy.default.height;
    container.style.width = sussy.default.width + "px";
    container.style.height = sussy.default.height + "px";

    /** @type {number} */
    let interval;

    $("#dpad button").on({
        "mousedown": function() {
            clearInterval(interval);

            const dir = $(this).data("dir");

            /** @type {Function} */
            const func = 
            dir == "up" ? () => pos.y-- :
            dir == "down" ? () => pos.y++ :
            dir == "left" ? () => pos.x-- :
            dir == "right" ? () => pos.x++ :
            null;

            if (func) {
                interval = setInterval(() => {
                    func();
                    render();
                }, 1000/30);
            }
            
        }
    });

    $(window).on("mouseup", () => clearInterval(interval));



    $("input:not(#txtColor)").on("change", render);


    // change color -> compile new sussy
    $("#txtColor").on("change", function() {
        const tempCanvas = document.createElement("canvas");
        const tempCtx = tempCanvas.getContext("2d");
        tempCanvas.width = canvas.emoji.width;
        tempCanvas.height = canvas.emoji.height;

        // draw sussy
        tempCtx.drawImage(sussy.default, 0, 0, tempCanvas.width, tempCanvas.height);

        // geting sussy overlay: "source-in" only fills rect where intersecting with sussy
        tempCtx.globalCompositeOperation = "source-in";
        tempCtx.fillStyle = $("#txtColor").val().toString();
        tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

        // now load sussy overlay into an image (can't apply globalCompositeOperation to imageData unfortunately)
        getImage(tempCanvas.toDataURL()).then(overlay => {
            tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);

            // draw sussy again
            tempCtx.globalCompositeOperation = "source-over";
            tempCtx.drawImage(sussy.default, 0, 0, tempCanvas.width, tempCanvas.height);
            
            // apply color
            tempCtx.globalCompositeOperation = "multiply";
            tempCtx.drawImage(overlay, 0, 0, tempCanvas.width, tempCanvas.height);

            // draw mask
            tempCtx.globalCompositeOperation = "source-over";
            tempCtx.drawImage(sussy.mask, 0, 0, tempCanvas.width, tempCanvas.height);


            getImage(tempCanvas.toDataURL()).then(result => {
                sussy.colored = result;
                render();
            })
        });

    }).trigger("change");




    $("#btnDownload").on("click", function() {
        const tempCanvas = document.createElement("canvas");
        const tempCtx = tempCanvas.getContext("2d");
        tempCanvas.width = canvas.sussy.width;
        tempCanvas.height = canvas.sussy.height;

        tempCtx.drawImage(canvas.emoji, 0, 0);
        tempCtx.drawImage(canvas.sussy, 0, 0);

        var link = document.createElement("a");
        link.download = "sussymoji.png";
        link.href = tempCanvas.toDataURL()
        link.click();
    });
}

function render() {
    const emoji = $("#txtEmoji").val().toString();
    ctx.emoji.font = $("#txtSize").val() + "px Arial";

    ctx.emoji.clearRect(0, 0, canvas.emoji.width, canvas.emoji.height);
    ctx.emoji.fillText(emoji, pos.x, pos.y);
    ctx.emoji.drawImage(sussy.colored, 0, 0);
}


Promise.all([
    getImage("img/sussy.png").then(img => sussy.default = img),
    getImage("img/mask.png").then(img => sussy.mask = img)
]).then(() => init());
    

/** @param {string} src */
function getImage(src) {
    return new Promise((resolve, reject) => {
        try {
            const img = new Image();
            img.onload = () => resolve(img);
            img.src = src;
        }
        catch (ex) {
            reject(ex);
        }
    });
}
