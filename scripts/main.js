import { getImage } from "../modules/img.js";
import EmojiPicker from "./emojiPicker.js";
const container = document.getElementById("container");
const canvas = document.getElementsByTagName("canvas")[0];
const ctx = canvas.getContext("2d");
ctx.textAlign = "center";
ctx.textBaseline = "middle";

/** @type {Object<string,HTMLImageElement>} */
const sussy = {
	base: null, // white sussy (no color)
	mask: null, // sussy mask
	colored: null, // colored sussy (generated by applying color to base and then drawing mask on top)
};

const emoji = {
	value: String.fromCodePoint(0x1f602),
	_size: 128,

	/** @param {number} val */
	set size(val) {
		//let diff = val - this._size;
		// offset position to keep emoji centered
		//emoji.pos.x = Math.round(emoji.pos.x - diff);
		//emoji.pos.y = Math.round(emoji.pos.y + diff);

		this._size = val;
		ctx.font = this._size + "px Arial";
	},
	get size() {
		return this._size;
	},

	pos: {
		x: 180,
		y: 220,
	},
};

const emojiPicker = new EmojiPicker("emojiPicker");
function init() {
	// scaling canvas
	sussy.base.width /= 4;
	sussy.base.height /= 4;
	canvas.width = sussy.base.width;
	canvas.height = sussy.base.height;
	container.style.width = sussy.base.width + "px";
	container.style.height = sussy.base.height + "px";

	emoji.size = 128;

	function render() {
		// clear -> draw emoji -> draw colored sussy
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		ctx.fillText(emoji.value, emoji.pos.x, emoji.pos.y);
		ctx.drawImage(sussy.colored, 0, 0);
	}

	// #region CONTROL EVENTS
	$("#horiz")
		.attr("max", canvas.width)
		.val(emoji.pos.x)
		.on("input", function () {
			emoji.pos.x = Number($(this).val());
			render();
		});

	$("#vert")
		.attr("max", canvas.height)
		.val(emoji.pos.y)
		.on("input", function () {
			emoji.pos.y = canvas.height - Number($(this).val());
			render();
		});

	$("#size").on("input", function () {
		emoji.size = Number($(this).val());
		render();
	});

	emojiPicker.onChange = (emojiVal) => {
		emoji.value = emojiVal;
		render();
	};

	// change color -> generate new colored sussy
	$("#color")
		.on("change", function () {
			const tempCanvas = document.createElement("canvas");
			tempCanvas.width = canvas.width;
			tempCanvas.height = canvas.height;

			const tempCtx = tempCanvas.getContext("2d");
			tempCtx.fillStyle = $(this).val().toString();

			// draw sussy
			tempCtx.drawImage(
				sussy.base,
				0,
				0,
				tempCanvas.width,
				tempCanvas.height
			);

			// geting sussy overlay: "source-in" only fills rect where intersecting with sussy
			tempCtx.globalCompositeOperation = "source-in";
			tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

			// now load sussy overlay into an image (can't apply globalCompositeOperation to imageData unfortunately)
			getImage(tempCanvas.toDataURL()).then((overlay) => {
				tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);

				// draw sussy again
				tempCtx.globalCompositeOperation = "source-over";
				tempCtx.drawImage(
					sussy.base,
					0,
					0,
					tempCanvas.width,
					tempCanvas.height
				);

				// apply color
				tempCtx.globalCompositeOperation = "multiply";
				tempCtx.drawImage(
					overlay,
					0,
					0,
					tempCanvas.width,
					tempCanvas.height
				);

				// draw mask
				tempCtx.globalCompositeOperation = "source-over";
				tempCtx.drawImage(
					sussy.mask,
					0,
					0,
					tempCanvas.width,
					tempCanvas.height
				);

				getImage(tempCanvas.toDataURL()).then((result) => {
					sussy.colored = result;
					render();
				});
			});
		})
		.trigger("change");

	// download -> create link to data url then click it
	$("#btnDownload").on("click", function () {
		const link = document.createElement("a");
		link.download = "sussymoji.png";
		link.href = canvas.toDataURL();
		link.click();
	});
	// #endregion
}

Promise.all([
	getImage("img/sussy.png").then((img) => (sussy.base = img)),
	getImage("img/mask.png").then((img) => (sussy.mask = img)),
]).then(() => init());
