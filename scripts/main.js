import { getImage } from "../modules/img.js";
import EmojiPicker from "../classes/emojiPicker.js";
import { Popup } from "../modules/popup.js";

import { getCookies, leaveCookie } from "../modules/cookie.js";

const cookie = getCookies();
leaveCookie(() => ({
	size: face.size.toString(),
	x: face.pos.x.toString(),
	y: face.pos.y.toString(),
}));

/** @param {any} obj
 * @param {number} defaultVal */
function getNumber(obj, defaultVal) {
	const num = Number(obj);
	return !isNaN(num) ? num : defaultVal;
}

const container = document.getElementById("container");
const canvas = document.getElementsByTagName("canvas")[0];
const ctx = canvas.getContext("2d");
ctx.textAlign = "center";
ctx.textBaseline = "middle";

/** @type {Object<string,HTMLImageElement>} */
const sussy = {
	base: null, // white sussy (no color)
	visor: null, // sussy mask
	colored: null, // colored sussy (generated by applying color to base and then drawing mask on top)
};

const face = {
	/** @type {HTMLImageElement} */
	_img: null,

	/** multiplier that gets applied to img width/height */
	size: getNumber(cookie.size, 1),

	/** @param {HTMLImageElement} img */
	set img(img) {
		this._img = img;
		$("#face").attr("src", img.src);
	},
	get img() {
		return this._img;
	},

	pos: {
		x: getNumber(cookie.x, 60),
		y: getNumber(cookie.y, 60),
	},
};

function render() {
	ctx.clearRect(0, 0, canvas.width, canvas.height);

	// need to draw from center so it scales from center
	const width = face.img.width * face.size;
	const height = face.img.height * face.size;
	const left = (face.pos.x / 100) * canvas.width - width / 2;
	const top = canvas.height - (face.pos.y / 100) * canvas.height - height / 2;

	// draw  face
	ctx.globalAlpha = 1;
	ctx.globalCompositeOperation = "source-over";
	ctx.drawImage(face.img, left, top, width, height);

	// clip to visor
	ctx.globalCompositeOperation = "destination-in";
	ctx.drawImage(sussy.visor, 0, 0);

	// re-draw sussy behind
	ctx.globalCompositeOperation = "destination-over";
	ctx.drawImage(sussy.colored, 0, 0);

	// draw visor on top (reduced opacity)
	ctx.globalAlpha = 0.33;
	ctx.globalCompositeOperation = "source-over";
	ctx.drawImage(sussy.visor, 0, 0);
}

function init() {
	// scaling canvas
	canvas.width = sussy.base.width;
	canvas.height = sussy.base.height;

	container.style.width = sussy.base.width / 4 + "px";
	container.style.height = sussy.base.height / 4 + "px";

	// #region CONTROL EVENTS
	$("#horiz")
		.val(face.pos.x)
		.on("input", function () {
			face.pos.x = Number($(this).val());
			render();
		});

	$("#vert")
		.val(face.pos.y)
		.on("input", function () {
			face.pos.y = Number($(this).val());
			render();
		});

	$("#size").on("input", function () {
		face.size = Number($(this).val());
		render();
	});

	// change color -> generate new colored sussy
	$("#color")
		.on("change", function () {
			const tempCanvas = document.createElement("canvas");
			tempCanvas.width = canvas.width;
			tempCanvas.height = canvas.height;

			const tempCtx = tempCanvas.getContext("2d");
			tempCtx.fillStyle = $(this).val().toString();

			// draw sussy
			tempCtx.drawImage(
				sussy.base,
				0,
				0,
				tempCanvas.width,
				tempCanvas.height
			);

			// geting sussy overlay: "source-in" only fills rect where intersecting with sussy
			tempCtx.globalCompositeOperation = "source-in";
			tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

			// now load sussy overlay into an image (can't apply globalCompositeOperation to imageData unfortunately)
			getImage(tempCanvas.toDataURL()).then((overlay) => {
				tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);

				// draw sussy again
				tempCtx.globalCompositeOperation = "source-over";
				tempCtx.drawImage(
					sussy.base,
					0,
					0,
					tempCanvas.width,
					tempCanvas.height
				);

				// apply color
				tempCtx.globalCompositeOperation = "multiply";
				tempCtx.drawImage(
					overlay,
					0,
					0,
					tempCanvas.width,
					tempCanvas.height
				);

				// draw visor
				//tempCtx.globalCompositeOperation = "source-over";
				//tempCtx.drawImage(sussy.visor, 0, 0, tempCanvas.width, tempCanvas.height);

				getImage(tempCanvas.toDataURL()).then((result) => {
					sussy.colored = result;
					render();
				});
			});
		})
		.trigger("change");

	// download -> create link to data url then click it
	$("#btnDownload").on("click", function () {
		const link = document.createElement("a");
		link.download = "sussymoji.png";
		link.href = canvas.toDataURL();
		link.click();
	});
	// #endregion
}

Promise.all([
	getImage("img/austo.png").then((img) => (face.img = img)),
	getImage("img/sussy.png").then((img) => (sussy.base = img)),
	getImage("img/visor.png").then((img) => (sussy.visor = img)),
]).then(() => init());

// #region PICKING FACE
class FaceTypePopup extends Popup {
	constructor() {
		super({
			classes: "face-type-popup",
			title: "Face Type",
			icon: "face",
			ok: {
				label: "Emoji",
				click: () => new EmojiPopup(),
			},
			cancel: {
				label: "Image",
				click: () => new ImagePopup(),
				class: "accent",
			},
		});
	}
}

class ImagePopup extends Popup {
	constructor() {
		/** @type {HTMLInputElement} */ let input;
		/** @type {HTMLImageElement} */ let img;

		super({
			title: "Upload Image",
			body: "<img></img><input type='file' accept='image/png, image/jpeg' class='marg-top-100' />",
			flex: "column",
			overflow: true,
			icon: "portrait",
			cancel: true,
			init: function (popup) {
				// @ts-ignore
				input = popup.$body
					.find("input[type='file']")
					.on("change", function () {
						if (input.files && input.files[0]) {
							const url = URL.createObjectURL(input.files[0]);
							console.log(url);
							img.src = url;
						}
					})
					.get(0);
				// @ts-ignore
				img = popup.$body.find("img").get(0);
			},
			ok: {
				click: function () {
					if (input.files && input.files[0]) {
						const url = URL.createObjectURL(input.files[0]);
						console.log(url);
						img.src = url;
						return getImage(url).then((result) => {
							face.img = result;
							render();
						});
					} else {
						return false;
					}
				},
			},
		});
	}
}

/** @type {String} emojiCarryover */
var emojiCarryover;
class EmojiPopup extends Popup {
	constructor() {
		/** @type {EmojiPicker} */
		let picker;
		super({
			title: "Pick Emoji",
			body: '<div id="emojiPicker"></div>',
			icon: "face",
			pad: "none",
			nomaximize: true,
			fullscreen: "mobile",
			init: () => picker = new EmojiPicker("emojiPicker", emojiCarryover),
			cancel: true,
			ok: function () {
				if (!picker.value) {
					Popup.error("No Emoji Selected");
					return false;
				}
				emojiCarryover = picker.value;
				// #region converting emoji to image
				const canvas = document.createElement("canvas");
				const ctx = canvas.getContext("2d");

				canvas.width = 512;
				canvas.height = 512;
				ctx.textAlign = "center";
				ctx.textBaseline = "middle";
				ctx.fillStyle = "black";
				ctx.font = "256px Arial";

				// measure text to get bounding box
				const metrics = ctx.measureText(picker.value);
				let height =
					metrics.actualBoundingBoxAscent +
					metrics.actualBoundingBoxDescent;

				// fill text then extract data within bounding box
				ctx.fillText(picker.value, canvas.width / 2, canvas.height / 2);
				const data = ctx.getImageData(
					canvas.width / 2 - metrics.width / 2,
					canvas.height / 2 - metrics.actualBoundingBoxAscent,
					metrics.width,
					height
				);

				// now rescale canvas and put image data back
				canvas.width = metrics.width;
				canvas.height = height;
				ctx.putImageData(data, 0, 0);

				return getImage(canvas.toDataURL()).then((result) => {
					face.img = result;
					render();
				});
				// #endregion
			},
		});
	}
}

$("#face").on("click", function () {
	new FaceTypePopup();
});
// #endreigon
